#!/usr/bin/env ruby

# Downloads all matching files in an S3 bucket.

require 'aws-sdk'
require 'fileutils'
require 'logger'
require 'powerpack'
require 'ruby-progressbar'
require 'trollop'
require 'yaml'

# @return [String] Banner for the help message.
def create_help_banner
  banner = <<-EOS
    Downloads all matching files in an S3 bucket.

    Usage:
        s3-download [options] <bucket name> [mask]

    where [options] are:
  EOS

  banner.strip_indent
end

# Creates and configures the logger.
#
# @param [Hash] opts Parsed command-line options.
#
# @return [Logger] Configured logger.
def create_logger(opts)
  logger = Logger.new(STDOUT)

  logger.level = case
                 when opts[:debug] then Logger::DEBUG
                 when opts[:verbose] then Logger::INFO
                 else Logger::WARN
                 end

  logger
end

# Loads the AWS configuration from the supplied path.
def load_aws_config(path)
  config = YAML.load_file(path)
  aws_config = AWS.config(config)
  logger.debug("AWS Configuration: #{aws_config.inspect}")
end

# Parses the command-line options.
#
# @return [Hash] Command-line options parsed representation.
def parse_options
  Trollop.options do
    banner create_help_banner

    opt :config,
        'Path to YAML file containing the AWS configuration',
        type: :string,
        default: "#{ENV['HOME']}/.aws/config"

    opt :debug, 'Outputs debug logging'
    opt :verbose, 'Outputs verbose logging'
  end
end

# Validates the command-line options.
def validate_options(opts)
  Trollop.die 'Must specify a bucket name' if ARGV[0].nil?

  # rubocop:disable Style/GuardClause
  unless File.exist?(opts[:config])
    Trollop.die :config, "Could not find configuration: #{opts[:config]}"
  end
  # rubocop:enable Style/GuardClause
end

opts = parse_options
validate_options(opts)
logger = create_logger(opts)

bucket_name = ARGV[0]
mask = ARGV[1] || '*'

logger.debug("Command-line options: #{opts.inspect}")
logger.debug("Command-line arguments: #{ARGV.inspect}")

load_aws_config(opts[:config])

# Get the bucket information
s3 = AWS::S3.new
bucket = s3.buckets[bucket_name]
matching_objects = bucket.objects.reject { |obj| obj.key.end_with?('/') }
                                 .select { |obj| File.fnmatch?(mask, obj.key) }

total_size = matching_objects.reduce { |sum, obj| sum + obj.content_length }

# Download each matching object
progress = ProgressBar.create(title: 'Total', total: total_size, format: '%t: |%B| %E')

matching_objects.each do |obj|
  progress.log(obj.key) if opts[:verbose] || opts[:debug]

  FileUtils.mkdir_p(File.dirname(obj.key))
  File.open(obj.key, 'wb') do |file|
    bucket.objects[obj.key].read do |chunk|
      file.write(chunk)
      progress.increment(chunk.length)
    end
  end
end

progress.finish
