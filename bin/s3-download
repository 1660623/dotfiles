#!/usr/bin/env ruby
# rubocop:disable FileName

# Downloads all matching files in an S3 bucket.

require 'aws-sdk'
require 'fileutils'
require 'logger'
require 'powerpack'
require 'ruby-progressbar'
require 'trollop'
require 'yaml'

# @return [String] Banner for the help message.
def create_help_banner
  banner = <<-EOS
    Downloads all matching files in an S3 bucket.

    Usage:
        s3-download [options] <bucket name> [mask]

    where [options] are:
  EOS

  banner.strip_indent
end

# @return [Logger] Default logger.
def create_logger
  logger = Logger.new(STDOUT)
  logger.level = Logger::WARN
  logger
end

# Loads the AWS configuration from the supplied path.
#
# @return [AWS::Configuration] AWS configuration information.
def load_aws_config(path)
  config = YAML.load_file(path)
  AWS.config(config)
end

# Parses the command-line options.
#
# @return [Hash] Command-line options parsed representation.
def parse_options
  Trollop.options do
    banner create_help_banner

    opt :config,
        'Path to YAML file containing the AWS configuration',
        type: :string,
        default: "#{ENV['HOME']}/.aws/config"

    opt :debug, 'Outputs debug logging'
    opt :verbose, 'Outputs verbose logging'
  end
end

# Validates the command-line options.
def validate_options(opts)
  Trollop.die 'Must specify a bucket name' if ARGV[0].nil?

  unless File.exist?(opts[:config])
    Trollop.die :config, "Could not find configuration: #{opts[:config]}"
  end
end

logger = create_logger
opts = parse_options
validate_options(opts)

logger.level = Logger::INFO if opts[:verbose]
logger.level = Logger::DEBUG if opts[:debug]

bucket_name = ARGV[0]
mask = ARGV[1] || '*'

logger.debug("Command-line options: #{opts.inspect}")
logger.debug("Command-line arguments: #{ARGV.inspect}")

aws_config = load_aws_config(opts[:config])
logger.debug("AWS Configuration: #{aws_config.inspect}")

# Get the bucket information
s3 = AWS::S3.new
bucket = s3.buckets[bucket_name]
matching_objects = bucket.objects.reject { |obj| obj.key.end_with?('/') }
                                 .select { |obj| File.fnmatch?(mask, obj.key) }

# Download each matching object
progress = ProgressBar.create(title: 'Total', total: matching_objects.count, format: '%t: |%B| %E')

matching_objects.each do |obj|
  progress.increment
  progress.log(obj.key) if opts[:verbose] || opts[:debug]

  FileUtils.mkdir_p(File.dirname(obj.key))
  File.open(obj.key, 'wb') do |file|
    bucket.objects[obj.key].read do |chunk|
      file.write(chunk)
    end
  end
end

progress.finish
